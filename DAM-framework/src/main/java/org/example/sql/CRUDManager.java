package org.example.sql;

import org.example.annotation.DepthLimit;
import org.example.annotation.ManyToOne;
import org.example.annotation.OneToMany;
import org.example.annotation.OneToOne;
import org.example.mapper.ActiveRecord;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import static org.example.mapper.ActiveRecord.*;

public class CRUDManager {
    private DatabaseAccessManagment dam;
    private SqlBuilderDirector sbd = new SqlBuilderDirector(new SqlBuilder());
    public CRUDManager(DatabaseAccessManagment dam){
        this.dam = dam;
    }
    public int insert(ActiveRecord obj) {
        String sql = sbd.insert(obj);
        int rowCount = 0;

        try (Connection connection = dam.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            obj.setParameters(statement);
            System.out.println(statement);
            rowCount = statement.executeUpdate();

            if (obj.isAutoGeneratedId()) {
                ResultSet generatedKeys = statement.getGeneratedKeys();
                if (generatedKeys.next()) {
                    obj.setAutoGeneratedId(generatedKeys);
                }
            }
            dam.closeConnection(connection);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return rowCount;
    }
    public int delete(ActiveRecord obj) {
        String sql = sbd.delete(obj);
        int rowCount = 0;

        try (Connection connection = dam.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            obj.setPrimaryKeyParameters(statement);
            rowCount = statement.executeUpdate();
            dam.closeConnection(connection);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return rowCount;
    }
    public int update(ActiveRecord obj){
        String sql = sbd.update(obj);
        int rowCount = 0;

        try (Connection connection = dam.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            obj.setPrimaryKeyParameters(statement);
            dam.closeConnection(connection);
            rowCount = statement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return rowCount;
    }
    public <T extends ActiveRecord> T selectFirst
            (String refTable, String condition, Object[] conditionValues, int maxDepth) {
        if (maxDepth <= 0) {
            return null;
        }
        Class clazz = getClassForTableName(refTable);
        String tableName = getTableNameFromClass(clazz);

        String sql = sbd.selectLimit(tableName, condition, 1);
        try (Connection connection = dam.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {

            for (int i = 0; i < conditionValues.length; i++) {
                statement.setObject(i + 1, conditionValues[i]);
            }

            try (ResultSet resultSet = statement.executeQuery()) {
                dam.closeConnection(connection);
                if (resultSet.next()) {
                    T object = newInstance(clazz);
                    setFieldsFromResultSet(object, resultSet, maxDepth);
                    object.setConnectionManager(dam);
                    return object;
                }
            }

        } catch (SQLException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }

        return null;
    }
//    public <T extends ActiveRecord> T selectFirst
//            (Class clazz, String sql, int maxDepth) {
//        if (maxDepth <= 0) {
//            return null;
//        }
//
//        try (Connection connection = dam.getConnection();
//             PreparedStatement statement = connection.prepareStatement(sql)) {
//
//            try (ResultSet resultSet = statement.executeQuery()) {
//                dam.closeConnection(connection);
//                if (resultSet.next()) {
//                    T object = newInstance(clazz);
//                    setFieldsFromResultSet(object, resultSet, maxDepth);
//                    object.setConnectionManager(dam);
//                    return object;
//                }
//            }
//
//        } catch (SQLException | InstantiationException | IllegalAccessException e) {
//            e.printStackTrace();
//        }
//
//        return null;
//    }
    public <T extends ActiveRecord> List<T> selectAll
            (String refTable, String condition, Object[] conditionValues, int maxDepth) {
        if (maxDepth <= 0) {
            return null;
        }
        Class clazz = getClassForTableName(refTable);
        String tableName = getTableNameFromClass(clazz);

        String sql = sbd.selectAll(tableName, condition);

        List<T> relatedObjects = new ArrayList<>();

        try (Connection connection = dam.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {

            for (int i = 0; i < conditionValues.length; i++) {
                statement.setObject(i + 1, conditionValues[i]);
            }

            try (ResultSet resultSet = statement.executeQuery()) {
                dam.closeConnection(connection);
                while (resultSet.next()) {
                    T object = newInstance(clazz);
                    setFieldsFromResultSet(object, resultSet, maxDepth);
                    object.setConnectionManager(dam);
                    relatedObjects.add(object);
                }
            }

        } catch (SQLException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }

        return relatedObjects;
    }
//    public <T extends ActiveRecord> List<T> selectAll
//            (Class clazz, String sql, int maxDepth) {
//        if (maxDepth <= 0) {
//            return null;
//        }
//
//        List<T> relatedObjects = new ArrayList<>();
//
//        try (Connection connection = dam.getConnection();
//             PreparedStatement statement = connection.prepareStatement(sql)) {
//
//            try (ResultSet resultSet = statement.executeQuery()) {
//                dam.closeConnection(connection);
//                while (resultSet.next()) {
//                    T object = newInstance(clazz);
//                    setFieldsFromResultSet(object, resultSet, maxDepth);
//                    object.setConnectionManager(dam);
//                    relatedObjects.add(object);
//                }
//            }
//
//        } catch (SQLException | InstantiationException | IllegalAccessException e) {
//            e.printStackTrace();
//        }
//
//        return relatedObjects;
//    }
    private void setOneToOneField(ActiveRecord object, Field field, ResultSet resultSet, OneToOne oneToOneAnnotation, int maxDepth) throws SQLException, IllegalAccessException {
        field.setAccessible(true);

        String refTable = oneToOneAnnotation.refTable();
        String joinColumn = oneToOneAnnotation.joinColumn();
        String refColumn = oneToOneAnnotation.refColumn();

        // Assuming you have a method to fetch a single record based on a condition
        String condition = refColumn + " = ?";
        Object joinColumnValue = resultSet.getObject(joinColumn);
        Object[] conditionValues = { joinColumnValue };


        // get class based on field

        Object referencedObject = selectFirst(refTable, condition, conditionValues, maxDepth - 1);


        field.set(object, referencedObject);

        field.setAccessible(false);
    }
    private void setFieldsFromResultSet(ActiveRecord object, ResultSet resultSet, int maxDepth) throws SQLException, IllegalAccessException {
        Class<?> clazz = object.getClass();

        DepthLimit depthLimitAnnotation = clazz.getAnnotation(DepthLimit.class);
        maxDepth = (depthLimitAnnotation != null) ? depthLimitAnnotation.value() : maxDepth;

        for (Field field : object.getClass().getDeclaredFields()) {
            if (!field.isSynthetic()) {
                field.setAccessible(true);

                // Handle other fields as usual
                OneToOne oneToOneAnnotation = field.getAnnotation(OneToOne.class);
                if (oneToOneAnnotation != null) {
                    setOneToOneField(object, field, resultSet, oneToOneAnnotation, maxDepth);
                }

                OneToMany oneToManyAnnotation = field.getAnnotation(OneToMany.class);
                if (oneToManyAnnotation != null) {
                    setOneToManyField(object, field, resultSet, oneToManyAnnotation, maxDepth);
                }

                ManyToOne manyToOneAnnotation = field.getAnnotation(ManyToOne.class);
                if (manyToOneAnnotation != null) {
                    setManyToOneField(object, field, resultSet, manyToOneAnnotation, maxDepth);
                }

                if (oneToOneAnnotation == null && oneToManyAnnotation == null && manyToOneAnnotation == null) {
                    field.set(object, resultSet.getObject(getColumnName(field)));
                }

                field.setAccessible(false);
            }
        }
    }
    private void setOneToManyField(ActiveRecord object, Field field, ResultSet resultSet, OneToMany oneToManyAnnotation, int maxDepth) throws SQLException, IllegalAccessException {
        field.setAccessible(true);

        String refTable = oneToManyAnnotation.refTable();
        String joinColumn = oneToManyAnnotation.joinColumn();
        String refColumn = oneToManyAnnotation.refColumn();

        // Assuming you have a method to fetch a list of records based on a condition
        String condition = refColumn + " = ?";
        Object joinColumnValue = resultSet.getObject(joinColumn);
        Object[] conditionValues = { joinColumnValue };


        // Retrieve the list of related objects
        List<ActiveRecord> relatedObjects = selectAll(refTable, condition, conditionValues, maxDepth - 1);

        // Set the collection of related objects to the field
        field.set(object, relatedObjects);

        field.setAccessible(false);
    }
    private void setManyToOneField(ActiveRecord object, Field field, ResultSet resultSet, ManyToOne manyToOneAnnotation, int maxDepth) throws SQLException, IllegalAccessException {
        field.setAccessible(true);

        String refTable = manyToOneAnnotation.refTable();
        String joinColumn = manyToOneAnnotation.joinColumn();
        String refColumn = manyToOneAnnotation.refColumn();

        // Assuming you have a method to fetch a single record based on a condition
        String condition = refColumn + " = ?";
        Object joinColumnValue = resultSet.getObject(joinColumn);
        Object[] conditionValues = { joinColumnValue };

        // get class based on field
        Object referencedObject = selectFirst(refTable, condition, conditionValues, maxDepth - 1);

        field.set(object, referencedObject);

        field.setAccessible(false);
    }
}
